<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <head>
        <title>Asar User Manual</title>
    </head>
    <body>
        <link rel="stylesheet" href="data/highlight_js/styles/default.css">
        <script src="data/highlight_js/highlight.pack.js"></script>
        <script type="text/javascript">
				hljs.configure(
					{
						tabReplace: '    ',
					}
				);
				hljs.initHighlightingOnLoad();
				
				function toggle_visibility(id)
				{
					var e =document.getElementById(id);
					var label = document.getElementById(id.concat("-toggle"));
					
					if(e.style.display == 'none')
					{
						label.innerHTML = label.innerHTML.replace("[+] Expand","[-] Collapse");
						e.style.display = 'block';
					}
					else
					{
						label.innerHTML = label.innerHTML.replace("[-] Collapse","[+] Expand");
						e.style.display = 'none';
					
					}
				}
		</script>
		<h1>Asar</h1>
        <p>A multi-architecture SNES assembler by <i>Alcaro</i>, based on <b>xkas v0.06</b> by <i>byuu</i>.</p>
		<hr />
		<p id="contents"><h3>Table of Contents</h3>
		<ul>
			<li><a href="#usage">Usage</a></li>
			<li><a href="#archs">Architectures</a></li>
			<li><a href="#mappers">Mapping Modes</a></li>
			<li>
				<a href="#behavior">Behavior Flags</a>
				<ul>
					<li><a href="#xkas">xkas</a></li>
					<li><a href="#asar">asar &lt;ver&gt;</a></li>
					<li><a href="#math-pri">math pri &lt;on/off&gt;</a></li>
					<li><a href="#math-round">math round &lt;on/off&gt;</a></li>
				</ul>
			</li>
			<li>
				<a href="#formatting">Code Formatting</a>
				<ul>
					<li><a href="#comments">Comments</a></li>
					<li><a href="#brackets">Brackets</a></li>
					<li><a href="#multiline">Multi-Line Operators</a></li>
				</ul>
			</li>
		</ul>
		</p>
		<hr />
        <p id="usage"><h3>Usage</h3>
        <pre><code class="powershell">	asar.exe [options] asm_file [rom_file]</code></pre>
		<table>
			<tr>
				<th style="width:150px">Argument</th>
				<th style="width:150px">Type</th>
				<th>Details</th>
				<th>Examples</th>
			</tr>
			<tr>
				<td><code class="powershell">options</code></td>
				<td></td>
				<td>List of optional arguments. The following options are supported:</td>
				<td></td>
			</tr>
			<tr>
				<td><code class="powershell">-I&lt;path&gt;</code><br /><code class="powershell">--include&nbsp;&lt;path&gt;</code></td>
				<td>Input</td>
				<td>Adds an include search path for file-based commands to Asar. Normally, commands like incsrc, incbin etc. look for files relative to the ASM file that is currently being compiled. If those files aren't found, an error is thrown, unless you specify include search paths, in which case Asar will look for the file in each respective directory before throwing an error. For example, imagine you compiled the file
				<pre><code class="powershell">C:/homebrew/my_game.asm</code></pre>
				with Asar, adding the include search path
				<pre><code class="powershell">-I"C:/homebrew/binary data"</code></pre>
				and the ASM file included the line:
				<pre><code class="mips">incbin data/player_gfx.bin</code></pre>
				Asar would now look for a file:
				<pre><code class="powershell">C:/homebrew/data/player_gfx.bin</code></pre>
				If this file didn't exist, it would then look for a file:
				<pre><code class="powershell">C:/homebrew/binary data/data/player_gfx.bin</code></pre>
				If this file didn't exist, Asar would throw an error, otherwise Asar would include it.
				</td>
				<td><pre><code class="powershell">asar.exe -IC:/homebrew/my_game/includes -IC:/homebrew/shared
	C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre>
	<pre><code class="powershell">asar.exe --include C:/homebrew/my_game/includes
	C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre></td>
			</tr>
			<tr>
				<td><code class="powershell">-D&lt;name&gt;=&lt;value&gt;</code><br /><code class="powershell">--define&nbsp;&lt;name&gt;=&lt;value&gt;</code></td>
				<td>Input</td>
				<td>Adds a define to Asar. See section <a href="#defines">Defines</a> for details.</td>
				<td><pre><code class="powershell">asar.exe -Ddebug=1 -Dskip_title_screen=0
	C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre>
	<pre><code class="powershell">asar.exe --define debug=1
	C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre></td>
			</tr>
			<tr>
				<td><code class="powershell">asm_file</code></td>
				<td>Input</td>
				<td>Path to the ASM source file.</td>
				<td><pre><code class="powershell">asar.exe C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre></td>
			</tr>
			<tr>
				<td><code class="powershell">rom_file</code></td>
				<td>Input, output</td>
				<td>Path to the ROM file that is modified by Asar. If this file doesn't exist yet, Asar creates a new ROM file instead. When omitted, Asar checks if asm_file_name.sfc or asm_file_name.smc exists and uses the one it finds. When zero or two ROMs with that filename are found, Asar defaults to the .sfc extension. As a convention, Asar always treats .smc files as headered and .sfc files as unheadered ROMs. This means that headered .sfc files or unheadered .smc files cannot be used with Asar unless their extension is changed. This is by design and meant to encourage compliance with the convention.</td>
				<td><pre><code class="powershell">asar.exe C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.sfc</code></pre>
				<pre><code class="powershell">asar.exe C:/homebrew/my_game/main.asm C:/homebrew/my_game/bin/my_game.smc</code></pre>
				<pre><code class="powershell">asar.exe C:/homebrew/my_game/main.asm</code></pre></td>
			</tr>
		</table>
		<br/ >
		For convenience, double-clicking the Asar executable will prompt you to enter paths to an ASM file and a ROM file and thus allow you to directly use Asar without passing any command line arguments to it.
		<br/ ><br/ >
		<a href="#contents">Return to top</a>
		</p>
		<hr />
        <p id="archs"><h3>Architectures</h3>
		Asar supports a number of different target architectures for code compilation. They can be activated via the command <code class="mips">arch &lt;name&gt;</code>. Going into detail on any of the supported architectures is beyond the scope of this manual. For that, it's recommended to check the SNES Dev Manual or other specialized resources. Asar tries as much as possible to always stick to the known conventions and specifications of each respective architecture.
		<br /><br />
		<table>
			<tr>
				<th style="width:150px">Architecture</th>
				<th style="width:150px">Command</th>
				<th style="width:150px">Supported Opcodes</th>
				<th>Details</th>
			</tr>
			<tr>
				<td>65c816</td>
				<td><code class="mips">arch&nbsp;65816</code></td>
				<td>
					<a href="javascript:void(0);" onclick="toggle_visibility('65816-opcodes');" id="65816-opcodes-toggle">[+] Expand</a>
					<div id="65816-opcodes" style="display:none;">
						<code class="mips">ADC #$00
ADC #$0000
ADC $00
ADC $00,s
ADC $00,x
ADC $0000
ADC $0000,x
ADC $0000,y
ADC $000000
ADC $000000,x
ADC ($00)
ADC ($00),y
ADC ($00,s),y
ADC ($00,x)
ADC [$00]
ADC [$00],y
AND #$00
AND #$0000
AND $00
AND $00,s
AND $00,x
AND $0000
AND $0000,x
AND $0000,y
AND $000000
AND $000000,x
AND ($00)
AND ($00),y
AND ($00,s),y
AND ($00,x)
AND [$00]
AND [$00],y
ASL $00
ASL $00,x
ASL $0000
ASL $0000,x
ASL A
BCC $00
BCS $00
BEQ $00
BIT #$00
BIT #$0000
BIT $00
BIT $00,x
BIT $0000
BIT $0000,x
BMI $00
BNE $00
BPL $00
BRA $00
BRK
BRK #$00
BRL $00
BVC $00
BVS $00
CLC
CLD
CLI
CLV
CMP #$00
CMP #$0000
CMP $00
CMP $00,s
CMP $00,x
CMP $0000
CMP $0000,x
CMP $0000,y
CMP $000000
CMP $000000,x
CMP ($00)
CMP ($00),y
CMP ($00,s),y
CMP ($00,x)
CMP [$00]
CMP [$00],y
COP
COP #$00
CPX #$00
CPX #$0000
CPX $00
CPX $0000
CPY #$00
CPY #$0000
CPY $00
CPY $0000
DEC $00
DEC $00,x
DEC $0000
DEC $0000,x
DEC A
DEX
DEY
EOR #$00
EOR #$0000
EOR $00
EOR $00,s
EOR $00,x
EOR $0000
EOR $0000,x
EOR $0000,y
EOR $000000
EOR $000000,x
EOR ($00)
EOR ($00),y
EOR ($00,s),y
EOR ($00,x)
EOR [$00]
EOR [$00],y
INC $00
INC $00,x
INC $0000
INC $0000,x
INC A
INX
INY
JML $000000
JML [$0000]
JMP $0000
JMP ($0000)
JMP ($0000,x)
JSL $000000
JSR $0000
JSR ($0000,x)
LDA #$00
LDA #$0000
LDA $00
LDA $00,s
LDA $00,x
LDA $0000
LDA $0000,x
LDA $0000,y
LDA $000000
LDA $000000,x
LDA ($00)
LDA ($00),y
LDA ($00,s),y
LDA ($00,x)
LDA [$00]
LDA [$00],y
LDX #$00
LDX #$0000
LDX $00
LDX $00,y
LDX $0000
LDX $0000,y
LDY #$00
LDY #$0000
LDY $00
LDY $00,x
LDY $0000
LDY $0000,x
LSR $00
LSR $00,x
LSR $0000
LSR $0000,x
LSR A
MVN $00,$00
MVP $00,$00
NOP
ORA #$00
ORA #$0000
ORA $00
ORA $00,s
ORA $00,x
ORA $0000
ORA $0000,x
ORA $0000,y
ORA $000000
ORA $000000,x
ORA ($00)
ORA ($00),y
ORA ($00,s),y
ORA ($00,x)
ORA [$00]
ORA [$00],y
PEA $0000
PEI ($00)
PER $0000
PHA
PHB
PHD
PHK
PHP
PHX
PHY
PLA
PLB
PLD
PLP
PLX
PLY
REP #$00
ROL $00
ROL $00,x
ROL $0000
ROL $0000,x
ROL A
ROR $00
ROR $00,x
ROR $0000
ROR $0000,x
ROR A
RTI
RTL
RTS
SBC #$00
SBC #$0000
SBC $00
SBC $00,s
SBC $00,x
SBC $0000
SBC $0000,x
SBC $0000,y
SBC $000000
SBC $000000,x
SBC ($00)
SBC ($00),y
SBC ($00,s),y
SBC ($00,x)
SBC [$00]
SBC [$00],y
SEC
SED
SEI
SEP #$00
STA $00
STA $00,s
STA $00,x
STA $0000
STA $0000,x
STA $0000,y
STA $000000
STA $000000,x
STA ($00)
STA ($00),y
STA ($00,s),y
STA ($00,x)
STA [$00]
STA [$00],y
STP
STX $00
STX $00,y
STX $0000
STY $00
STY $00,x
STY $0000
STZ $00
STZ $00,x
STZ $0000
STZ $0000,x
TAX
TAY
TCD
TCS
TDC
TRB $00
TRB $0000
TSB $00
TSB $0000
TSC
TSX
TXA
TXS
TXY
TYA
TYX
WAI
WDM
WDM #$00
XBA
XCE</code>
					</div>
				</td>
				<td>Default setting. Compiles code for the 65c816 architecture.</td>
			</tr>
			<tr>
				<td>SPC700</td>
				<td><code class="mips">arch&nbsp;spc700</code></td>
				<td>
					<a href="javascript:void(0);" onclick="toggle_visibility('spc700-opcodes');" id="spc700-opcodes-toggle">[+] Expand</a>
					<div id="spc700-opcodes" style="display:none;">
						<code class="mips">ADC $00,#$00
ADC $00,$00
ADC (X),(Y)
ADC A,#$00
ADC A,$00
ADC A,$00+X
ADC A,$0000
ADC A,$0000+X
ADC A,$0000+Y
ADC A,($00)+Y
ADC A,($00+X)
ADC A,(X)
ADDW YA,$00
AND $00,#$00
AND $00,$00
AND (X),(Y)
AND A,#$00
AND A,$00
AND A,$00+X
AND A,$0000
AND A,$0000+X
AND A,$0000+Y
AND A,($00)+Y
AND A,($00+X)
AND A,(X)
AND1 C,!$0000
AND1 C,$0000
ASL $00
ASL $00+X
ASL $0000
ASL A
BBC0 $00,$00
BBC1 $00,$00
BBC2 $00,$00
BBC3 $00,$00
BBC4 $00,$00
BBC5 $00,$00
BBC6 $00,$00
BBC7 $00,$00
BBS0 $00,$00
BBS1 $00,$00
BBS2 $00,$00
BBS3 $00,$00
BBS4 $00,$00
BBS5 $00,$00
BBS6 $00,$00
BBS7 $00,$00
BCC $00
BCS $00
BEQ $00
BMI $00
BNE $00
BPL $00
BRA $00
BRK
BVC $00
BVS $00
CALL $0000
CBNE $00+x,$00
CBNE $00,$00
CLR0 $00
CLR1 $00
CLR2 $00
CLR3 $00
CLR4 $00
CLR5 $00
CLR6 $00
CLR7 $00
CLRC
CLRP
CLRV
CMP $00,#$00
CMP $00,$00
CMP (X),(Y)
CMP A,#$00
CMP A,$00
CMP A,$00+X
CMP A,$0000
CMP A,$0000+X
CMP A,$0000+Y
CMP A,($00)+Y
CMP A,($00+X)
CMP A,(X)
CMP X,#$00
CMP X,$00
CMP X,$0000
CMP Y,#$00
CMP Y,$00
CMP Y,$0000
CMPW YA,$00
DAA A
DAS A
DBNZ $00,$00
DBNZ Y,$00
DEC $00
DEC $00+X
DEC $0000
DEC A
DEC X
DEC Y
DECW $00
DI
DIV YA,X
EI
EOR $00,#$00
EOR $00,$00
EOR (X),(Y)
EOR A,#$00
EOR A,$00
EOR A,$00+X
EOR A,$0000
EOR A,$0000+X
EOR A,$0000+Y
EOR A,($00)+Y
EOR A,($00+X)
EOR A,(X)
EOR1 C,$0000
INC $00
INC $00+X
INC $0000
INC A
INC X
INC Y
INCW $00
JMP $0000
JMP ($0000+X)
LSR $00
LSR $00+X
LSR $0000
LSR A
MOV $00+X,A
MOV $00+X,Y
MOV $00+Y,X
MOV $00,#$00
MOV $00,$00
MOV $00,A
MOV $00,X
MOV $00,Y
MOV $0000+X,A
MOV $0000+Y,A
MOV $0000,A
MOV $0000,X
MOV $0000,Y
MOV ($00)+Y,A
MOV ($00+X),A
MOV (X),A
MOV (X+),A
MOV A,#$00
MOV A,$00
MOV A,$00+X
MOV A,$0000
MOV A,$0000+X
MOV A,$0000+Y
MOV A,($00)+Y
MOV A,($00+X)
MOV A,(X)
MOV A,(X+)
MOV A,X
MOV A,Y
MOV SP,X
MOV X,#$00
MOV X,$00
MOV X,$00+Y
MOV X,$0000
MOV X,A
MOV X,SP
MOV Y,#$00
MOV Y,$00
MOV Y,$00+X
MOV Y,$0000
MOV Y,A
MOV1 $0000,C
MOV1 C,$0000
MOVW $00,YA
MOVW YA,$00
MUL YA
NOP
NOT1 $0000
NOTC
OR $00,#$00
OR $00,$00
OR (X),(Y)
OR A,#$00
OR A,$00
OR A,$00+X
OR A,$0000
OR A,$0000+X
OR A,$0000+Y
OR A,($00)+Y
OR A,($00+X)
OR A,(X)
OR1 C,!$0000
OR1 C,$0000
PCALL $00
POP A
POP P
POP X
POP Y
PUSH A
PUSH P
PUSH X
PUSH Y
RET
RETI
ROL $00
ROL $00+X
ROL $0000
ROL A
ROR $00
ROR $00+X
ROR $0000
ROR A
SBC $00,#$00
SBC $00,$00
SBC (X),(Y)
SBC A,#$00
SBC A,$00
SBC A,$00+X
SBC A,$0000
SBC A,$0000+X
SBC A,$0000+Y
SBC A,($00)+Y
SBC A,($00+X)
SBC A,(X)
SET0 $00
SET1 $00
SET2 $00
SET3 $00
SET4 $00
SET5 $00
SET6 $00
SET7 $00
SETC
SETP
SLEEP
STOP
SUBW YA,$00
TCALL 0
TCALL 1
TCALL 2
TCALL 3
TCALL 4
TCALL 5
TCALL 6
TCALL 7
TCALL 8
TCALL 9
TCALL 10
TCALL 11
TCALL 12
TCALL 13
TCALL 14
TCALL 15
TCLR $0000,a
TSET $0000,a
XCN A</code>
					</div>
				</td>
				<td>Compiles code for the SPC700 architecture. Follows the format the SNES Dev Manual recommends, with the exception of mov (x)+,a and mov a,(x)+, which are moved to mov (x+),a and mov a,(x+).</td>
			</tr>
			<tr>
				<td>SPC700</td>
				<td><code class="mips">arch&nbsp;spc700-inline</code></td>
				<td></td>
				<td>Same as above, but implements the standard upload system (16bit length, then location, with a terminator at the end) automatically.</td>
			</tr>
			<tr>
				<td>Super FX</td>
				<td><code class="mips">arch&nbsp;superfx</code></td>
				<td>
					<a href="javascript:void(0);" onclick="toggle_visibility('superfx-opcodes');" id="superfx-opcodes-toggle">[+] Expand</a>
					<div id="superfx-opcodes" style="display:none;">
						<code class="mips">ADC #0
ADC #0
ADC #1
ADC #2
ADC #3
ADC #4
ADC #5
ADC #6
ADC #7
ADC #8
ADC #9
ADC #10
ADC #11
ADC #12
ADC #13
ADC #14
ADC #15
ADC R0
ADC R1
ADC R2
ADC R3
ADC R4
ADC R5
ADC R6
ADC R7
ADC R8
ADC R9
ADC R10
ADC R11
ADC R12
ADC R13
ADC R14
ADC R15
ADD #0
ADD #1
ADD #2
ADD #3
ADD #4
ADD #5
ADD #6
ADD #7
ADD #8
ADD #9
ADD #10
ADD #11
ADD #12
ADD #13
ADD #14
ADD #15
ADD R0
ADD R1
ADD R2
ADD R3
ADD R4
ADD R5
ADD R6
ADD R7
ADD R8
ADD R9
ADD R10
ADD R11
ADD R12
ADD R13
ADD R14
ADD R15
ALT1
ALT2
ALT3
AND #1
AND #2
AND #3
AND #4
AND #5
AND #6
AND #7
AND #8
AND #9
AND #10
AND #11
AND #12
AND #13
AND #14
AND #15
AND R1
AND R2
AND R3
AND R4
AND R5
AND R6
AND R7
AND R8
AND R9
AND R10
AND R11
AND R12
AND R13
AND R14
AND R15
ASR
BCC $00
BCS $00
BEQ $00
BGE $00
BIC #1
BIC #2
BIC #3
BIC #4
BIC #5
BIC #6
BIC #7
BIC #8
BIC #9
BIC #10
BIC #11
BIC #12
BIC #13
BIC #14
BIC #15
BIC R1
BIC R2
BIC R3
BIC R4
BIC R5
BIC R6
BIC R7
BIC R8
BIC R9
BIC R10
BIC R11
BIC R12
BIC R13
BIC R14
BIC R15
BLT $00
BMI $00
BNE $00
BPL $00
BRA $00
BVC $00
BVS $00
CACHE
CMODE
CMP R0
CMP R1
CMP R2
CMP R3
CMP R4
CMP R5
CMP R6
CMP R7
CMP R8
CMP R9
CMP R10
CMP R11
CMP R12
CMP R13
CMP R14
CMP R15
COLOR
DEC R0
DEC R1
DEC R2
DEC R3
DEC R4
DEC R5
DEC R6
DEC R7
DEC R8
DEC R9
DEC R10
DEC R11
DEC R12
DEC R13
DEC R14
DIV2
FMULT
FROM R0
FROM R1
FROM R2
FROM R3
FROM R4
FROM R5
FROM R6
FROM R7
FROM R8
FROM R9
FROM R10
FROM R11
FROM R12
FROM R13
FROM R14
FROM R15
GETB
GETBH
GETBL
GETBS
GETC
HIB
IBT R0,#$00
IBT R1,#$00
IBT R2,#$00
IBT R3,#$00
IBT R4,#$00
IBT R5,#$00
IBT R6,#$00
IBT R7,#$00
IBT R8,#$00
IBT R9,#$00
IBT R10,#$00
IBT R11,#$00
IBT R12,#$00
IBT R13,#$00
IBT R14,#$00
IBT R15,#$00
INC R0
INC R1
INC R2
INC R3
INC R4
INC R5
INC R6
INC R7
INC R8
INC R9
INC R10
INC R11
INC R12
INC R13
INC R14
IWT R0,#0000
IWT R1,#0000
IWT R2,#0000
IWT R3,#0000
IWT R4,#0000
IWT R5,#0000
IWT R6,#0000
IWT R7,#0000
IWT R8,#0000
IWT R9,#0000
IWT R10,#0000
IWT R11,#0000
IWT R12,#0000
IWT R13,#0000
IWT R14,#0000
IWT R15,#0000
JMP R8
JMP R9
JMP R10
JMP R11
JMP R12
JMP R13
LDB (R0)
LDB (R1)
LDB (R2)
LDB (R3)
LDB (R4)
LDB (R5)
LDB (R6)
LDB (R7)
LDB (R8)
LDB (R9)
LDB (R10)
LDB (R11)
LDW (R0)
LDW (R1)
LDW (R2)
LDW (R3)
LDW (R4)
LDW (R5)
LDW (R6)
LDW (R7)
LDW (R8)
LDW (R9)
LDW (R10)
LDW (R11)
LEA R0,$0000
LINK #1
LINK #2
LINK #3
LINK #4
LJMP R8
LJMP R9
LJMP R10
LJMP R11
LJMP R12
LJMP R13
LM R0,($0000)
LM R1,($0000)
LM R2,($0000)
LM R3,($0000)
LM R4,($0000)
LM R5,($0000)
LM R6,($0000)
LM R7,($0000)
LM R8,($0000)
LM R9,($0000)
LM R10,($0000)
LM R11,($0000)
LM R12,($0000)
LM R13,($0000)
LM R14,($0000)
LM R15,($0000)
LMS R0,($00)
LMS R1,($00)
LMS R2,($00)
LMS R3,($00)
LMS R4,($00)
LMS R5,($00)
LMS R6,($00)
LMS R7,($00)
LMS R8,($00)
LMS R9,($00)
LMS R10,($00)
LMS R11,($00)
LMS R12,($00)
LMS R13,($00)
LMS R14,($00)
LMS R15,($00)
LMULT
LOB
LOOP
LSR
MERGE
MOVE ($00),R0
MOVE R0,#$00
MOVE R0,($00)
MOVE R0,R0
MOVEB (R0),R0
MOVEB R0,(R0)
MOVES R0,R0
MOVEW (R0),R0
MOVEW R0,(R0)
MULT #0
MULT #1
MULT #2
MULT #3
MULT #4
MULT #5
MULT #6
MULT #7
MULT #8
MULT #9
MULT #10
MULT #11
MULT #12
MULT #13
MULT #14
MULT #15
MULT R0
MULT R1
MULT R2
MULT R3
MULT R4
MULT R5
MULT R6
MULT R7
MULT R8
MULT R9
MULT R10
MULT R11
MULT R12
MULT R13
MULT R14
MULT R15
NOP
NOT
OR #1
OR #2
OR #3
OR #4
OR #5
OR #6
OR #7
OR #8
OR #9
OR #10
OR #11
OR #12
OR #13
OR #14
OR #15
OR R1
OR R2
OR R3
OR R4
OR R5
OR R6
OR R7
OR R8
OR R9
OR R10
OR R11
OR R12
OR R13
OR R14
OR R15
PLOT
RAMB
ROL
ROMB
ROR
RPIX
SBC R0
SBC R1
SBC R2
SBC R3
SBC R4
SBC R5
SBC R6
SBC R7
SBC R8
SBC R9
SBC R10
SBC R11
SBC R12
SBC R13
SBC R14
SBC R15
SBK
SEX
SM ($0000),R0
SM ($0000),R1
SM ($0000),R2
SM ($0000),R3
SM ($0000),R4
SM ($0000),R5
SM ($0000),R6
SM ($0000),R7
SM ($0000),R8
SM ($0000),R9
SM ($0000),R10
SM ($0000),R11
SM ($0000),R12
SM ($0000),R13
SM ($0000),R14
SM ($0000),R15
SMS ($00),R0
SMS ($00),R1
SMS ($00),R2
SMS ($00),R3
SMS ($00),R4
SMS ($00),R5
SMS ($00),R6
SMS ($00),R7
SMS ($00),R8
SMS ($00),R9
SMS ($00),R10
SMS ($00),R11
SMS ($00),R12
SMS ($00),R13
SMS ($00),R14
SMS ($00),R15
STB (R0)
STB (R1)
STB (R2)
STB (R3)
STB (R4)
STB (R5)
STB (R6)
STB (R7)
STB (R8)
STB (R9)
STB (R10)
STB (R11)
STOP
STW (R0)
STW (R1)
STW (R2)
STW (R3)
STW (R4)
STW (R5)
STW (R6)
STW (R7)
STW (R8)
STW (R9)
STW (R10)
STW (R11)
SUB #0
SUB #1
SUB #2
SUB #3
SUB #4
SUB #5
SUB #6
SUB #7
SUB #8
SUB #9
SUB #10
SUB #11
SUB #12
SUB #13
SUB #14
SUB #15
SUB R0
SUB R1
SUB R2
SUB R3
SUB R4
SUB R5
SUB R6
SUB R7
SUB R8
SUB R9
SUB R10
SUB R11
SUB R12
SUB R13
SUB R14
SUB R15
SWAP
TO R0
TO R1
TO R2
TO R3
TO R4
TO R5
TO R6
TO R7
TO R8
TO R9
TO R10
TO R11
TO R12
TO R13
TO R14
TO R15
UMULT #0
UMULT #1
UMULT #2
UMULT #3
UMULT #4
UMULT #5
UMULT #6
UMULT #7
UMULT #8
UMULT #9
UMULT #10
UMULT #11
UMULT #12
UMULT #13
UMULT #14
UMULT #15
UMULT R0
UMULT R1
UMULT R2
UMULT R3
UMULT R4
UMULT R5
UMULT R6
UMULT R7
UMULT R8
UMULT R9
UMULT R10
UMULT R11
UMULT R12
UMULT R13
UMULT R14
UMULT R15
WITH R0
WITH R1
WITH R2
WITH R3
WITH R4
WITH R5
WITH R6
WITH R7
WITH R8
WITH R9
WITH R10
WITH R11
WITH R12
WITH R13
WITH R14
WITH R15
XOR #1
XOR #2
XOR #3
XOR #4
XOR #5
XOR #6
XOR #7
XOR #8
XOR #9
XOR #10
XOR #11
XOR #12
XOR #13
XOR #14
XOR #15
XOR R1
XOR R2
XOR R3
XOR R4
XOR R5
XOR R6
XOR R7
XOR R8
XOR R9
XOR R10
XOR R11
XOR R12
XOR R13
XOR R14
XOR R15</code>
					</div>
				</td>
				<td>Compiles code for the Super FX architecture.</td>
			</tr>
		</table>
		<br />
		All of Asar's features should be compatible with all of the supported target architectures, but it's not recommended to mix labels between different architectures as that will lead to undefined behavior. Opcodes in Asar are case-insensitive, which means that <code class="mips">LDA</code> and <code class="mips">lda</code> will be treated equally.
		<pre><code class="mips">arch 65816
LDA $00

arch spc700
MOV A,$00</code></pre>
		<a href="#contents">Return to top</a></p>
		<hr />
        <p id="mappers"><h3>Mapping Modes</h3>
		<a href="#contents">Return to top</a></p>
		<hr />
        <p id="behavior"><h3>Behavior Flags</h3>
		Behavior flags are certain commands and settings that determine how Asar operates in certain situations.
		<h4 id="xkas">xkas</h4>
		The <code class="mips">xkas</code> command enables Asar's xkas compatibility mode. In this mode, Asar tries to replicate the behavior of xkas as much as possible and throws warnings whenever it detects the usage of Asar-specific features that are not compatible with xkas. This command has to be used before any other command in the same patch. The intended purpose of the xkas command is to use it in conjunction with <code class="mips">;@</code> to write patchs that can be assembled with both, Asar and xkas. See section <a href="#comments">Comments</a> for details. Note that as of Asar version 1.40, xkas backwards compatibility is officially deprecated and is no longer guaranteed to work as expected. New features introduced into Asar since then might not throw warnings when attempted to use in xkas compatibility mode and old xkas patches might not assemble correctly with Asar anymore, even when xkas compatibility mode is used.
		<pre><code class="mips">;@xkas

!is_asar=0	
;@!is_asar=1

;@if !is_asar == 0
	macro do_something()
		; Do something xkas-specific here
	endmacro
;@else
;@	macro do_something()
;@		; Do something asar-specific here
;@	endmacro
;@endif

do_something()</code></pre>
		<h4 id="asar">asar &lt;ver&gt;</h4>
		The <code class="mips">asar</code> command can be used to specify the minimum Asar version your patch is compatible with. When a user tries to assemble the patch in an older version of Asar, an error will be thrown, stating that the used Asar version is too old. This should be the first command in your patch, otherwise an error will be thrown.
		<pre><code class="mips">; This patch uses features from Asar 1.40, so it makes sense to require it as a minimum.
@asar 1.40

if readfile1("data.bin", 0) == 1
	; Do something
else
	; Do something else
endif</code></pre>
		<h4 id="math-pri">math pri &lt;on/off&gt;</h4>
		The <code class="mips">math pri</code> command tells Asar which order of operations to use in math experssions. When set to off (default), Asar uses left-to-right math, just like xkas v0.06. When set to on, Asar follows the conventional oder of operations (exponentiation before multiplication & division, multiplication & division before addition & subtraction etc.). Parentheses can be used in either mode and tell Asar to calculate the expression inside first. For most intents and purposes, working with this flag enabled is more practical and predictable. It is disabled by default solely for the purpose of xkas backwards compatibility. When writing patches specifially for Asar, it is recommended to always enable this flag.
		<pre><code class="mips">math pri off
db 1+(6/3)*5	; db 15

math pri on
db 1+(6/3)*5	; db 11</code></pre>
		<h4 id="math-round">math round &lt;on/off&gt;</h4>
		The <code class="mips">math round</code> command tells Asar which rounding behavior to use in math expressions. When set to on (default), Asar truncates all numbers immediately, whereas when set to off, Asar only truncates numbers whenever they need to be cast to an integer type. Note that having this flag enabled will make it practically impossible to work with floating point numbers since calculations will lead to unexpected and impractical results. It is the default setting solely for the purpose of xkas backwards compatibility. When writing patches specifially for Asar, it is recommended to always disable this flag.
		<pre><code class="mips">math round on
; 1.75 is immediately truncated to 1, resulting in (3/4)+1
; 3/4 would result in 0.75, which is immediately truncated to 0, resulting in 0+1
; Thus leading to the final result of "db 1"
db (3/4)+1.75

; !some_number contains 0 after this line
!some_number #= 0.75

math round off
; As expected will result in 0.75+1.75, which will result in 2.5
; 2.5 is truncated to 2
; Thus leading to the final result of "db 2"
db (3/4)+1.75

; !some_number contains 0.75 after this line
!some_number #= 0.75</code></pre>
<a href="#contents">Return to top</a></p>
		<hr />
        <p id="formatting"><h3>Code Formatting</h3>
		<h4 id="comments">Comments</h3>
		You can use ; to add comments to your code, making it easier to read and understand for other people. Everything from the ; to the end of the line is silently ignored by Asar.
		<pre><code class="mips">	lda $00		; Asar only sees the lda $00 and ignores everything else</code></pre>
		An exception from this rule are lines starting with <code class="mips">;@</code>, which are assembled normally. The purpose of this is to add code to your patch that can be used with both xkas and Asar. In xkas, lines with ;@ will simply be ignored, whereas in Asar, they will be assembled. If you don't care about backwards-compatibility, you can also just use <code class="mips">@</code>, which will make your patch only assemble with Asar and fail with xkas. Aditionally, when Asar finds any unknown command on a line starting with ;@ or @, it will only throw a warning instead of an error. This can, at least in theory, be used to include optional features from newer Asar versions and still have your patch be compatible with older Asar versions. See section <a href="#behavior">Behavior Flags</a> for details on xkas compatibility.
		<h4 id="brackets">Brackets</h3>
        Brackets, { and }, may be used to help organize your code structurally. They're treated as commands by the assembler, which means they follow the same rules as other commands, but they otherwise have no effect on code assembly and are silently ignored. Since brackets have no effect on code assembly, they don't even have to match, either. It's compltely up to you whether, how and in what quantity you want to use them.<br />
		<pre><code class="mips">	lda $00
	beq .is_zero
	
.greater_than_zero
	{
		dec $00
	}

.is_zero
	rts</code></pre>
		<h4 id="multiline">Multi-Line Operators</h3>
		The <code class="mips">,</code> and the <code class="mips">\</code> operator are formatting operators which make it possible to split commands in Asar into multiple lines. Both are put at the end of a line and work very similarly with only one key difference. During execution, Asar will concatenate subsequent lines to lines ending with either operator and treat them as a single line. When using the comma operator, the comma itself will actually remain a part of the concatenated string, whereas when using the backslash operator, the backslash itself will be removed from the concatenated string. When using the backslash operator, please note that all whitespace following it is ignored, whereas all whitespace preceeding it is preserved. This is by design, since some commands in Asar require spaces to work, whereas other commands (like math commands) only work without spaces.
		<pre><code class="mips">%some_macro(!arg1, !arg2, !arg3,
	!arg4, !arg5, !arg6)
; This will be treated as "%some_macro(!arg1, !arg2, !arg3, !arg4, !arg5, !arg6)"

lda \
	$7F0000
; This will be treated as "lda $7F0000"

function f(x) = ((x*x)+1000)\
	/256
; This will treated as "function f(x) = ((x*x)+1000)/256"</code></pre>
		<br /><a href="#contents">Return to top</a></p>
		<hr />
        <b>Labels / Sublabels / +/- Labels:</b><br>
        A label is used to represent a position in code, and allows one to code
        without having to constantly update branches and jumps/calls. A label
        should be able to be used in any opcode, but was specifically added to
        be used with branches, jumps, and calls. When used with branches, they're automatically converted to offsets. Labels can contain A-Za-z0-9_.
        They must end with :<br>
        A sublabel is used to declare labels within labels that will share its
        address space only, and can contain the same characters as a label, but
        must start with a period. A sublabel must not, but can, end with a :.
        Here's an example:<br>
        <hr>
        proc1:<br>
        &nbsp;&nbsp;nop<br>
        .l1<br>
        &nbsp;&nbsp;bra .l1<br>
        proc2:<br>
        &nbsp;&nbsp;nop<br>
        .l1<br>
        &nbsp;&nbsp;bra .l1<br>
        ;The two opcodes below will branch back and forth forever.<br>
        &nbsp;&nbsp;- bra +<br>
        &nbsp;&nbsp;+ bra -<br>
        <hr>
        Sublabels allow you to reuse redundantly named labels such as loop,
        end,
        etc. without causing duplicate label conflicts. A new sublabel group is
        started immediately after a label is declared automatically. A +/-
        label
        can be up to 3 levels deep, e.g. +, ++, +++, -, --, ---. They overwrite
        their pc offsets immediately after being redefined. Useful for very
        short
        loops, when even something like .loop would become redundant in a long
        routine.<br>
		Asar will optimize label access from 24bit addressing to 16bit if possible.<br>
        Lastly, there are labels specifically for macros. They are identical to
        real labels, and begin with a ?<br>
        Example: ?label:<br>
        Do not use these outside of macros!!
        <br>
        <br>
        <b>Defines:</b><br>
        Asar uses a pretty powerful define system, which does quite a bit more
        than a typical define. To start, they are prefixed with !<br>
        Syntax to declare a define is as follows, both are identical:<br>
        !x = *<br>
        !y equ *<br>
        You must have a space on both side of the separator, e.g. ' = ', or
        ' equ '. !x=* will not work.
        A define can be anything, a label, another define, a math formula, it
        can include the formatting for the opcode or not, etc.
        Here are some examples:<br>
        !x = $00<br>
        lda !x ;lda $00<br>
        lda #!x ;lda #$00<br>
        !x equ [$00],y<br>
        lda !x ;lda [$00],y<br>
        !y = $12<br>
        !x = !y$34<br>
        lda !x ;lda $1234<br>
        !phr = "pha : phx : phy"<br>
        !phr<br>
        If you need to use spaces within your define, then you
        must use quotes around the right hand side of the operand, as shown
        above
        with !phr.<br>
        <br>
        <b>Macros:</b><br>
        Macros can be nested (macros with macros) up to 512 levels deep, the
        limitation is there only to prevent macro a calling macro b, and vice
        versa, resulting in a dead-lock of the assembler. incsrc, below, has
        the
        same 512 level deep limit, for exactly the same reason. Syntax of a
        macro
        is:<br>
        <hr>
        macro name(arg1, arg2, ...)<br>
        ?loop:<br>
        lda &lt;arg1&gt;<br>
        sta.l $&lt;arg2&gt;<br>
        bra ?loop<br>
        endmacro<br>
        <hr>
        Things to note: The first and last line from the above example must be
        on their own lines, you cannot use the : command to concatenate these
        commands. You can use as many arguments as you like. Yes, infinite
        arguments, if you like. Or none at all. To use the argument within the
        macro, simply use &lt;&gt; around the argument name. To use the
        macro
        within your code, use %macroname(arg1, ...).
        This accepts quotes, as well.<br>
        This example would be valid: %writestr(3, "Hello", "pha : plb")
        <br>
        <br>
        <b>Opcode size specifications:</b>
        You can specify the size of an opcode with .b, .w, and .l<br>
        This is needed with decimal, e.g. lda #0.. is that lda #$00, or
        lda #$0000? You would have to use lda.b #0, or lda.w #0.<br>
        I do not use the standard ! &lt; &gt; as size specifiers,
        namely because I
        already use these for defines, shifts, and macro arguments. Sorry if
        you
        don't like not having these, but there isn't an easy workaround,
        I'm afraid.<br>
        <br>
        <b>: Separator</b><br>
        The : is used to allow multiple opcodes on the same line. It requires
        a space before and after usage, to differentiate it from the : used
        to end labels.<br>
        Example: lda #$00 : sta $00<br>
        This is useful for making each line define an action, rather than just
        an opcode. Very useful when combined with { } to indicate a structural
        flow of assembly code, rather than a straight descending list. But
        you're
        free to code however you like.<br>
        <br>
        <b># psuedo-opcodes:</b><br>
        For convenience, I have added psuedo-opcodes to commonly used opcodes,
        such as nop, asl, lsr, inc, inx, iny, dec, dex, dey, etc. You can
        specify
        asl #4, which will print the equivalent of asl : asl : asl : asl to the
        file, the same goes for the other opcodes.<br>
        <br>
        <b>Math:</b><br>
        Math is supported in all opcodes, and all functions, however, it has
        one major variation from traditional math. It does not resolve math
        in order if symbols, it instead resolves from left to right, and also
        does not use parinthesis to denote order. An example:<br>
        <i>Standard Math:</i><br>
        &nbsp;&nbsp;&nbsp;mov a,5+6*2 ;=17<br>
        <i>Left-to-right Math:</i><br>
        &nbsp;&nbsp;&nbsp;mov a,6*2+5 ;=17<br>
        &nbsp;&nbsp;&nbsp;mov a,5+6*2 ;=22<br>
        I do apologize for this limitation, it was just far easier and faster
        to implement left-to-right math, and for an assembler, I haven't really
        come across anything that could not be represented in left-to-right
        math.
        To use left-to-right math, just reorder your multiplication and
        division
        to the start, and use addition and subtraction at the end. The math
        system
        supports the following commands:<br>
        + : Addition<br>
        - : Subtraction<br>
        * : Multiplication<br>
        / : Division<br>
        &lt;&lt; : Left-shift ( x&lt;<y formula="" x="x" *="" 2^y="" )=""><br>
        &gt;&gt; : Right-shift ( x &gt;&gt; y formula: x = x /
        2^y )<br>
        &amp; : Bitwise AND<br>
        | : Bitwise OR<br>
        ^ : Bitwise XOR (Note: Not exponentials)<br>
        ~ : Bitwise NOT<br>
        <br>
        <br>
        Math also works with labels. Example:<br>
        mov a,label2-label1+2<br>
        <br>
        <u><b>Additional Commands:</b></u><br>
        <br>
        <b>hirom:</b><br>
        Use hirom addressing.<br>
        <br>
        <b>lorom:</b><br>
        Use lorom addressing.<br>
        <br>
        <b>rep:</b><br>
        Repeat the following command x times. Works with almost all commands supported by Asar and even macro calls.<br>
        Example:<br/>
		rep 5 : nop ;write nop 5 times<br/>
		rep 2 : do_something() ; Calls do_something() macro twice
        <br>
        <b>fill / fillbyte:</b><br>
        fillbyte will allow you to select the byte used by fill, and fill can
        be
        used to fill x number of bytes with the fillbyte. Example:<br>
        fillbyte $ff : fill 16<br>
        This will write 16 $ff's to the file, and will increment the pc counter
        automatically.<br>
        <br>
        <b>pad / padbyte:</b><br>
        This is identical to fill / fillbyte, except that pad takes an offset
        instead of a number of bytes to write. It will continue writing bytes
        until the offset is reached. Example:<br>
        org $8000 : padbyte $ff : pad $8010<br>
        This will write 16 $ff's to the file, and will increment the pc counter
        automatically.<br>
        <br>
        <b>db / dw / dl / dd:</b><br>
        These are used to write binary data to the file.<br>
        </li>
        <li>db - 8-bit byte write mode<br></li>
        <li>dw - 16-bit word write mode<br></li>
        <li>dl - 24-bit long write mode<br></li>
        <li>
            dd - 32-bit dword write mode<br>
            Multiple arguments can be passed to these commands by means of a comma.
            Example:<br>
            db $01,$02,$03,$04<br>
            dw $0001,$0002,$0003,$0004<br>
            This command also accepts labels and text as arguments, example:<br>
            dw label : db "This is a test",$00<br>
            Text is written using the ascii table by default, however, there
            is table support, see below.<br>
            <br>
            <b>table / cleartable:</b><br>
            cleartable will reset the ascii lookup-table to the ascii character
            map.<br>
            table filename will load in a file, which contains a character map,
            and format it using left-to-right mode.<br>
            table filename,ltr will load the file in left-to-right mode.<br>
            table filename,rtl will load the file in right-to-left mode.<br>
            left-to-right mode table example:<br>
            A=00<br>
            B=01<br>
            C=02<br>
            ...<br>
            right-to-left mode table example:<br>
            00=A<br>
            01=B<br>
            02=C<br>
            ...<br>
            Use whichever you prefer.<br>
            <br>
            <b>skip:</b><br>
            Skip ahead x bytes.<br>
            Example: skip 5 ;skips ahead 5 bytes in the file.<br>
            <br>
            <b>namespace:</b><br>
            namespaces can be used to declare labels with the same name, useful to
            prefix all labels with a certain extension, e.g. for a library.<br>
            Example:<br>
            <hr>
            namespace "lf1_" ;set namespace to "lf1_"<br>
            main: ;this will become "lf1_main" when referenced with namespaces off<br>
            namespace off ;turn namespace functionality off<br>
            main: ;no conflicts with identical labels due to namespaces<br>
            jsr lf1_main ;call our library function<br>
            <hr>
            Somewhat useful, I suppose...<br>
            <br>
            <b>print:</b><br>
            print allows you to print text to the console window, useful for
            debugging.<br>
            Example: "main is at pc : ",pc<br>
            That will print "main is at pc : xxxxxx", where x is the PC location.
            It accepts infinite arguments, comma separated, all should be strings,
            there are a few special commands, however. They are:<br>
            pc - print current pc location<br>
            bytes - print # of bytes written to the file, use to determine the size
            of routines, for size optimizations and so forth.<br>
            I wanted to add cycles, but unfortunately, it's too unreliable. The
            cycle
            count will change depending on the p register, if branches are taken,
            if writing to the dp has the d with an even value, etc. Too many
            variables
            to be viable, sorry.<br>
            You can use: reset bytes to reset that counter.
            <br>
            <br>
            <b>incsrc:</b><br>
            Assemble included file. There is a 512-deep recursion limit. (e.g.
            incsrc
            inside an incsrc inside an incsrc...) - See the macro definitions for
            why this is here. It will assemble the included file immediately when
            hit.
            So if your incsrc is in the middle of the file, that's where it's
            going.
            All labels/sublabels/etc. are in the global-scope. So if you have
            label1:
            defined in file1.asm, then incsrc file2.asm, file2 will be able to use
            label1:, and subsequently not be able to redefine it.<br>
			incsrc, incbin and similar commands will look for the referenced files in the folder the current file is in (if you're in a macro, it's
			relative to the macro, not the caller). By using include search paths (see section <a href="#usage">Usage</a> for details), you can influence Asar's behavior for when a file isn't found in that location.
            <br><br>
			<b>incbin:</b><br>
			The incbin command will let you insert a binary file into the output
			binary image. Usage:<br>
			incbin filename.bin<br>
			<br>
            <b>org:</b><br>
            org is used to set the file position. It will update pc, as well. You
            can
            seek forward and backward into a file.<br>
            <br>
            <b>warnpc:</b><br>
            warnpc takes an address, it will compare the current
            pc
            to the address you specified, if the current address is &gt; the
            address
            specified, it will throw an error. Useful if you want your code to
            be between x and y, and data to be between y and z. You can make sure
            your code isn't so large that it exceeds y this way.<br>
            <br>
            <b>base:</b><br>
            base is used to set the pc position without affecting the file
            location.<br>
            Example: org $c00000 : base $7f8000 : ... : base off<br>
            This is useful for assembling code at $c00000, that you plan to execute
            in RAM, at $7f80000. You can turn the base address translation off at
            any time, as seen above. Note that I've never actually seen code run in
            RAM before, and I don't even know if it would be possible to execute
            code
            in RAM or not, but the function is here either way...<br>
            <br>
            <u><b>Opcodes:</b></u><br>
            I pretty much followed the accepted standards for opcodes, this isn't
            the SPC-700, where there are 40 variations between programmers for
            nearly
            every single opcode. You shouldn't have any trouble here.
        </li>
    </body>
</html>

